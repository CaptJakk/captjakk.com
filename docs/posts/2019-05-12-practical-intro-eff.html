<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>CaptJakk's Blog - A Practical Introduction to Freer Monads (Eff)</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <link href="https://fonts.googleapis.com/css?family=Inconsolata|Open+Sans&display=swap" rel="stylesheet">
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">CaptJakk</a>
            </div>
            <nav>
                <a href="../">Posts</a>
                <a href="../about.html">About</a>
            </nav>
        </header>

        <main role="main">
            <h1>A Practical Introduction to Freer Monads (Eff)</h1>
            <article>
    <section class="header">
        Posted on May 12, 2019
        
    </section>
    <section>
        <h1 id="background">Background</h1>
<p>For the remainder of this post I’m going to assume that you roughly understand what a monad is, or can at least understand how you would use one in a codebase that has an actual <code>main</code> method. If not, fear not, there are a number of wonderful resources out there to teach you this, however, unless you have that context, the rest of this post will seem useless, complicated, or both.</p>
<h1 id="motivation">Motivation</h1>
<p>I could sit here and talk about the theoretical underpinnings that make Free/r monads interesting, but there are far more qualified people than I to talk about such things. And while they are certainly interesting in their own right, I want to take a step back, de-emphasize the theory, and talk about something more concrete. And while you may have never exactly encountered the scenarios I’m about to lay out, the essence of the frustration should seem eerily familiar.</p>
<h2 id="requirements-thrash">Requirements Thrash</h2>
<p>Have you ever gotten the requirements of a project, coded it, delivered it to the stakeholder(s), and had them accept it without a fuss the first time around? Yeah, me neither. They always want to tweak something between that v0 you hand them before arriving at whatever becomes the stable solution for the time being</p>
<p>Now, of course, this is fine. We want to satisfy our customers and write software that actually does what people want it to do, but when designing this stuff, there are certain decisions you can make that make your own life difficult if you try to change it later.</p>
<p>In most cases, when people ask you to make something, there’s a very small set of its implementation that they care about, and that’s usually the original API that they actually specify. Technical debates about whether you should store the data in Postgres or on the Filesystem, or debates about whether caching is done in memory or in Redis, are things <em>you</em> get to decide. <em>Your PM’s don’t give a shit.</em></p>
<p>So given that you’re building software for them in the first place, why would you spend any time on the implementation details before getting the high level semantics down right?</p>
<p>Of course, that stuff still has to get done before you can actually ship the code, but a demo is worth a thousand requirements meetings. People realistically don’t know what they want until they see it, so can we somehow show them a version of what the system will look like before we get to all the grimy engineering details of making it fault tolerant, performant, etc.?</p>
<p>hmm…</p>
<p>Before we answer that, let’s take a look at another situation.</p>
<h2 id="testing">Testing</h2>
<p>Testing is an interesting subject to talk about in Haskell because with such a sophisticated type system we often find that when our software compiles it will “just work”. Now this isn’t technically true because any monomorphic function <code>Foo -&gt; Bar -&gt; Baz</code> can have many different implementations that satisfy that type signature, and almost certainly, at least one of them is wrong.</p>
<p>So while there are entire categories of tests we don’t have to write that people writing Ruby or JS have to, the number of tests we have to write is still nonzero. Now, for pure functions we have some pretty world-class tooling such as <code>quickcheck</code> and <code>hedgehog</code> which I’ve been favoring more recently, but these things are primarily focused on testing <em>data transformations</em>.</p>
<p>However, sometimes we want to be able to write a test that ensures that <em>actions</em> produce other actions that may not have a representation in the return type of your function. After all, how would you go about testing whether a function <code>Foo -&gt; IO Bar</code> worked correctly? If it was supposed to log the value of type <code>Foo</code> before grabbing the right <code>Bar</code> out of the database and returning it, how do we make sure that log event happened?</p>
<p>It’d be nice if we could plug and play logging implementations depending on whether we were in a test environment or the real application. But to do that we need to be able to parameterize part of that function. The trouble is that we <em>know</em> this function needs to take a <code>Foo</code> as an argument and yield a <code>Bar</code> as a result. So what else is there to parameterize? Can we parameterize the monad it’s running in to be <code>Foo -&gt; m Bar</code> and then depending on the environment instantiate <code>m</code> with either <code>IO</code> or some test monad?</p>
<p>This is roughly how the strategy of mocking things works in OOP. But we can’t let them have nicer things than us. Is there a way we can accomplish all the same things?</p>
<p>Let’s visit one final frustration before we get to the answer.</p>
<h2 id="prove-you-cant-launch-nukes">Prove you can’t <em>Launch Nukes™</em></h2>
<p>If you spend even a little bit of time in Haskell you’ll start to lean pretty heavily on type signatures to get an idea of what a particular piece of code is doing. <code>Asset -&gt; Price</code> probably gives you the price of that asset, which is loads better than a comparable signature <code>String -&gt; Double</code>. Not only because it constrains the input and output types, but also makes a good faith effort to describe what the function is doing in a very “TL;DR” manner.</p>
<p>So what is the least descriptive type signature ever?</p>
<p>Well, given that Haskell is a general purpose programming language, and than Turing Completeness makes it such that anything that is computable should be expressible, it stands to reason that the type signature of our <code>main</code> method is about the most useless type signature ever, since <em>any program at all</em> can satisfy it. So what is that type signature?</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">IO</span> ()</a></code></pre></div>
<p>Any program at all can inhabit that type. This means without scrutinizing its contents we have no idea what it does. And while <code>()</code> is a somewhat worthless return type since it only has one inhabitant, it’s not the scariest part of this type signature. The structurally similar <code>Identity ()</code> is a lot clearer about what it can, or more importantly <em>can’t</em>, do.</p>
<p>So why is <code>IO</code> so scary? Because it’s more or less like giving root to someone. Once given control, it can do whatever it wants before giving control back to the caller.</p>
<p>Nevertheless, if we want to write useful programs we need to be able to do things that require <code>IO</code>. But what we’d want to do is constrain the <em>types</em> of <code>IO</code> it can do, and make it clear in the type signature that those are all it requires.</p>
<p>So we want some system of specifying which types of <code>IO</code>, henceforth referred to as <em>effects</em>, in such a way that if we needed to add more effects to that function we could easily do it, but still be forced to say that is what we are doing.</p>
<p>Enter Eff.</p>
<h1 id="what-is-eff">What is Eff?</h1>
<p>Eff is a structure with some beautiful theoretical underpinnings that allows us to deal with the above phenomena in a tractable and scalable way. It’s main value proposition is bisecting your effectful code into a “what” and a “how”, along with a method of choosing the “how” at a different call site than the what. There are numerous implementations of this idea, and the one that we’ll be referencing throughout the rest of this post is <a href="https://hackage.haskell.org/package/freer-simple">freer-simple</a>.</p>
<p>Your business logic cares about the “what”, but your execution environment is what cares about the “how”.</p>
<h2 id="minimum-viable-eff-effect">Minimum Viable Eff effect</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">Console</span> a <span class="kw">where</span> <span class="co">-- GADT that defines the types of operations in this API</span></a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="dt">GetLine</span><span class="ot"> ::</span> <span class="dt">Console</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="dt">PutLine</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Console</span> ()</a>
<a class="sourceLine" id="cb2-4" title="4">makeEffect '<span class="dt">'Console</span> <span class="co">-- TH code that generates the functions you'll use in business logic</span></a></code></pre></div>
<p>So what’s going on here? We have a datatype that describes some <code>Console</code> effect that has two operations: <code>GetLine</code> which is some effectful way of getting a <code>String</code>, and <code>PutLine</code> which takes a <code>String</code> and does something with it and gives you back <code>()</code></p>
<p>But the magic is not in the datatype it’s in the following function definitions that are generated automatically by the Template Haskell <code>makeEffect</code> declaration:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">getLine</span><span class="ot"> ::</span> <span class="dt">Member</span> <span class="dt">Console</span> r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="fu">getLine</span> <span class="ot">=</span> send <span class="dt">GetLine</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">putLine ::</span> <span class="dt">Member</span> <span class="dt">Console</span> r <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> r ()</a>
<a class="sourceLine" id="cb3-5" title="5">putLine <span class="ot">=</span> send <span class="op">.</span> <span class="dt">PutLine</span></a></code></pre></div>
<p>What is happening here is that <code>r</code> is a <em>type-level list</em> of effects, and the <code>Member</code> constraint is saying that <code>Console</code> must appear in that list somewhere. Finally, <code>send</code> is merely allowing us to use these effects together with each other in a “mix and match” fashion, without having to worry about the machinery that keeps all of this type-safe.</p>
<p>What this does is it takes the constructors for that datatype and “injects” them into the <code>Eff r</code> monad that is completely polymorphic in r with a constraint that the Console effect is in there somewhere.</p>
<p>Keep in mind, we haven’t said shit about how this thing is supposed to get or put lines anywhere. We’ve just said, “hey, we want to do get and put to the console, and we’ll worry about how to do it some other time”. So let’s consider the following program</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">greetBot ::</span> <span class="dt">Member</span> <span class="dt">Console</span> r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r ()</a>
<a class="sourceLine" id="cb4-2" title="2">greetBot <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-3" title="3">    putLine <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb4-4" title="4">    name <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb4-5" title="5">    putLine <span class="op">$</span> <span class="st">&quot;Hello, &quot;</span> <span class="op">&lt;&gt;</span> name <span class="op">&lt;&gt;</span> <span class="st">&quot;!\n&quot;</span></a>
<a class="sourceLine" id="cb4-6" title="6">    greetBot</a></code></pre></div>
<p>Neat. This program, from a structural standpoint looks like how we would code a bot that repeatedly asks for your name and then greets you. We aren’t bogged down with the details about how to get that string or send out the greeting. The code only specifies the high level design of the program. The skeptical reader might say, well we can do that without all this Eff machinery by just pulling out <code>getLine :: IO String</code> and <code>putLine :: String -&gt; IO ()</code> to their own function. And not only that, but <code>base</code> already does this for us. So what have we really accomplished?</p>
<p>The answer is that not only have we packed that logic elsewhere, but we haven’t even committed to a particular implementation yet! There are no typed holes, no <code>undefined</code>s and we still can have a program that typechecks without having committed to these details.</p>
<p>That said, this program is still incomplete and won’t yet run, precisely because we haven’t actually told it how to handle these gets and puts.</p>
<p>So what are we going to do in the regular program case? The aforementioned functions in base will do just fine I think:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">consoleToIO ::</span> <span class="dt">Console</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb5-2" title="2">consoleToIO action <span class="ot">=</span> <span class="kw">case</span> action <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="dt">GetLine</span> <span class="ot">-&gt;</span> Prelude.getLine</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="dt">PutLine</span> s <span class="ot">-&gt;</span> Prelude.putStrLn s</a></code></pre></div>
<p>This is all great, but <code>greetBot</code> isn’t actually a program of type <code>Console a</code>. Instead, it is one that that has the type <code>Eff r a</code> where the only requirement on <code>r</code> is that it is a list that contains <code>Console</code> in it somewhere. The minimum concretion of <code>greetBot</code> could have type <code>Eff '[Console] ()</code>, but the point here is that it is not <em>limited</em> to that, and can be combined at will with other effects, that, in conjunction, build up a much larger list.</p>
<p>Once this list is built, though, we need a way to independently interpret these effects. We also need to do this in such a way that we can define the handler with no knowledge of anything besides the source and target effects. We want this so that our effects can remain isolated from one another but can be composed together to interpret more complicated programs.</p>
<p>This is where the value of effect libraries such as <code>freer-simple</code> start to shine.</p>
<p><code>freer-simple</code> gives us some functions to be able to take the above action mapping and use it in the context of the <code>Eff</code> machinery.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">translate ::</span> (<span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> g a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> (f '<span class="op">:</span> r) b <span class="ot">-&gt;</span> <span class="dt">Eff</span> (g '<span class="op">:</span> r) b</a>
<a class="sourceLine" id="cb6-2" title="2">translate <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ot">runM ::</span> <span class="dt">Eff</span> '[m] a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb6-5" title="5">runM <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">-- to close the gap</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="ot">interpretConsoleInIO ::</span> <span class="dt">Eff</span> '[<span class="dt">Console</span>] a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb6-9" title="9">interpretConsoleInIO <span class="ot">=</span> runM <span class="op">.</span> translate consoleToIO</a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="ot">main ::</span> <span class="dt">IO</span> () <span class="co">-- this translation to IO happens at the edge of our program</span></a>
<a class="sourceLine" id="cb6-12" title="12">main <span class="ot">=</span> interpretConsoleInIO greetBot</a></code></pre></div>
<p>Great! But how do we test it? I promised testing capabilities, I should deliver on it. To really do that we need to tweak the original program just a bit so we can just test a single iteration of it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">greetBot ::</span> <span class="dt">Member</span> <span class="dt">Console</span> r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r ()</a>
<a class="sourceLine" id="cb7-2" title="2">greetBot <span class="ot">=</span> fix greetBot'</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">greetBot' ::</span> <span class="dt">Member</span> <span class="dt">Console</span> r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r () <span class="ot">-&gt;</span> <span class="dt">Eff</span> r ()</a>
<a class="sourceLine" id="cb7-5" title="5">greetBot' continue <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-6" title="6">    putLine <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb7-7" title="7">    name <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb7-8" title="8">    putLine <span class="op">$</span> <span class="st">&quot;Hello, &quot;</span> <span class="op">&lt;&gt;</span> name <span class="op">&lt;&gt;</span> <span class="st">&quot;!\n&quot;</span></a>
<a class="sourceLine" id="cb7-9" title="9">    continue</a></code></pre></div>
<p>We have to do this because if we try to test a program that loops forever the test will never terminate itself. So we’ll actually be testing greetBot’ here.</p>
<p>What is a natural way we might want to test this? Well, the main invariant here is that the thing emitted over the put should at least contain the name obtained via the get. Let’s write out a property test for this.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="co">-- hedgehog property test</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">prop_nameMatchesGreeting ::</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb8-3" title="3">prop_nameMatchesGreeting <span class="ot">=</span> property <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-4" title="4">    name <span class="ot">&lt;-</span> forAll nameGenerator</a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6">    _ <span class="co">-- uhhh, what goes here?</span></a></code></pre></div>
<p>So we’ve run into our first issue, we want to be able to supply a name that was given to us from the test environment to our program directly. So we want <code>greetBot'</code> to <em>read</em> for its <code>getLine</code> call and <em>write</em> for its <code>putLine</code> call. Can we interpret our Console action into more than one effect? Turns out yes.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="co">-- freer simple provides some out of the box reader and writer effects that behave the same way</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">-- that their identically named monads in `base` behave</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="ot">consoleToReaderAndWriter ::</span> ( <span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">String</span>) r</a>
<a class="sourceLine" id="cb9-4" title="4">                            , <span class="dt">Member</span> (<span class="dt">Writer</span> [<span class="dt">String</span>]) r</a>
<a class="sourceLine" id="cb9-5" title="5">                            ) <span class="ot">=&gt;</span> <span class="dt">Console</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</a>
<a class="sourceLine" id="cb9-6" title="6">consoleToReaderAndWriter action <span class="ot">=</span> <span class="kw">case</span> action <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-7" title="7">    <span class="dt">GetLine</span> <span class="ot">-&gt;</span> ask</a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="dt">PutLine</span> s <span class="ot">-&gt;</span> tell s</a></code></pre></div>
<p>And with the appropriate functions from <code>freer-simple</code> we can interpet this down to a pure value!</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="co">-- used to get from Console to Reader AND Writer</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">reinterpret2 ::</span> (<span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (g '<span class="op">:</span> h '<span class="op">:</span> r) a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> (f '<span class="op">:</span> r) b <span class="ot">-&gt;</span> <span class="dt">Eff</span> (g '<span class="op">:</span> h '<span class="op">:</span> r) b</a>
<a class="sourceLine" id="cb10-3" title="3">reinterpret2 <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb10-4" title="4"></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">-- used to discharge reader</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="ot">runReader ::</span> env <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="dt">Reader</span> env '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</a>
<a class="sourceLine" id="cb10-7" title="7">runReader <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="co">-- used to discharge writer</span></a>
<a class="sourceLine" id="cb10-10" title="10"><span class="ot">runWriter ::</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Eff</span> (<span class="dt">Writer</span> w '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Eff</span> r (a, w)</a>
<a class="sourceLine" id="cb10-11" title="11">runWriter <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb10-12" title="12"></a>
<a class="sourceLine" id="cb10-13" title="13"><span class="co">-- used to discharge Eff machinery around a pure value</span></a>
<a class="sourceLine" id="cb10-14" title="14"><span class="ot">run ::</span> <span class="dt">Eff</span> '[] a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-15" title="15">run <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb10-16" title="16"></a>
<a class="sourceLine" id="cb10-17" title="17"><span class="co">-- to close the gap between our mapping and the function we want</span></a>
<a class="sourceLine" id="cb10-18" title="18"><span class="ot">interpretConsoleInReaderWriter ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> '[<span class="dt">Console</span>] a <span class="ot">-&gt;</span> (a, [<span class="dt">String</span>])</a>
<a class="sourceLine" id="cb10-19" title="19">interpretConsoleInReaderWriter env <span class="ot">=</span></a>
<a class="sourceLine" id="cb10-20" title="20">    run <span class="op">.</span> </a>
<a class="sourceLine" id="cb10-21" title="21">    runReader env <span class="op">.</span> </a>
<a class="sourceLine" id="cb10-22" title="22">    runWriter <span class="op">.</span> </a>
<a class="sourceLine" id="cb10-23" title="23">    reinterpret2 consoleToReaderWriter</a></code></pre></div>
<p>OK. So now that we’ve defined our testing interpreter we’re ready to complete that property test.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="co">-- hedgehog property test</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">prop_nameMatchesGreeting ::</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb11-3" title="3">prop_nameMatchesGreeting <span class="ot">=</span> property <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-4" title="4">    name <span class="ot">&lt;-</span> forAll nameGenerator</a>
<a class="sourceLine" id="cb11-5" title="5"></a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="kw">let</span> consoleOutput <span class="ot">=</span> <span class="fu">snd</span> <span class="op">$</span> interpretConsoleInReaderWriter name (greetBot' <span class="op">$</span> <span class="fu">pure</span> ())</a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="kw">case</span> consoleOutput <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-9" title="9">        [] <span class="ot">-&gt;</span> failure <span class="co">-- nothing was emitted</span></a>
<a class="sourceLine" id="cb11-10" title="10">        (line<span class="op">:</span>_) <span class="ot">-&gt;</span> assert <span class="op">$</span> name <span class="ot">`isInfixOf`</span> line</a></code></pre></div>
<p>Boom! We just wrote a test that tests effects working properly within the context of our business logic.</p>
<p>Let’s recap what just happened. With quite minimal overhead we defined a new capability <code>Console</code> to be used throughout our application. We defined the interpreter we want it to use in the production environment, as well as an interpreter that allows us to control inputs and measure outputs in our test environment. Additionally, we gained the ability to write business logic without committing to a <code>Console</code> implementation. And finally, our business logic more explicitly states the capabilities it needs.</p>
<h2 id="can-we-do-this-to-everything">Can we do this to everything?</h2>
<p>The short answer here is yes. You absolutely can go ham on making effect algebras for everything in your entire codebase, but every effect you introduce gives you some extra overhead. So my rule of thumb is this: If you have some well defined semantics for your API, or you need to be able to mock it out for testing, it’s a pretty good candidate for an Eff effect. Otherwise, you probably lose more than you gain from this.</p>
<p>All that said, some people have taken this much further and have some really interesting results.</p>
<h1 id="time-for-the-majors">Time for the Majors</h1>
<p>OK. So the example above is pretty compelling (at least to me), but when was the last time you actually wrote a program that only did reads and writes to the console. It was probably the first thing you learned to do when you learned to code so it doesn’t really accurately reflect the problems you deal with in industrial software, right?</p>
<p>Wrong. There are some reasons that you may not want to use this technique in production and I’ll get to those at the end, but inability to express all of the things that you need is not on that list.</p>
<h2 id="problem-statement">Problem Statement</h2>
<p>So what we want to do is create a server that continuously fetches prices from third parties, aggregates them some way, saves them, and then serves up the result on request.</p>
<p>It might be tempting to say that a web service that does this seems too simple to be useful, however, if any of my colleagues were reading this, they’d tell you it looks awfully similar to a service we have currently running in production.</p>
<h2 id="lets-write-some-new-effects">Let’s write some new effects!</h2>
<p>Ok. So immediately what jumps out at me is that since the problem statement was intentionally vague about the third parties in question, and the method of saving, those are the candidates for…wait for it…<em>free-monadification</em>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">data</span> <span class="dt">AssetPairing</span> <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">data</span> <span class="dt">Price</span> <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">data</span> <span class="dt">Exchange</span> <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb12-4" title="4"></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="kw">data</span> <span class="dt">PriceFeed</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-6" title="6">    <span class="dt">FetchPrice</span><span class="ot"> ::</span> <span class="dt">Exchange</span> <span class="ot">-&gt;</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">PriceFeed</span> <span class="dt">Price</span></a>
<a class="sourceLine" id="cb12-7" title="7">makeEffect '<span class="dt">'PriceFeed</span></a>
<a class="sourceLine" id="cb12-8" title="8"></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="kw">data</span> <span class="dt">PriceStore</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-10" title="10">    <span class="dt">SavePrice</span><span class="ot"> ::</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">Price</span> <span class="ot">-&gt;</span> <span class="dt">PriceStore</span> ()</a>
<a class="sourceLine" id="cb12-11" title="11">    <span class="dt">GetMostRecentPrice</span><span class="ot"> ::</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">PriceStore</span> <span class="dt">Price</span></a>
<a class="sourceLine" id="cb12-12" title="12">makeEffect '<span class="dt">'PriceStore</span></a></code></pre></div>
<h2 id="time-to-make-the-pms-happy">Time to make the PM’s happy</h2>
<p>With just the code above we’re actually ready to write our business logic.</p>
<p>For the daemons continuously fetching and saving we have this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">allExchanges ::</span> [<span class="dt">Exchange</span>]</a>
<a class="sourceLine" id="cb13-2" title="2">allExchanges <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb13-3" title="3"></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="ot">getPricesFromAllSources ::</span> <span class="dt">Member</span> <span class="dt">PriceFeed</span> effs <span class="ot">=&gt;</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> effs [<span class="dt">Price</span>]</a>
<a class="sourceLine" id="cb13-5" title="5">getPricesFromAllSources assetPairing <span class="ot">=</span> for allExchanges <span class="op">$</span> \exchange <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-6" title="6">   fetchPrice exchange assetPairing</a>
<a class="sourceLine" id="cb13-7" title="7"></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="ot">aggregatePrices ::</span> [<span class="dt">Price</span>] <span class="ot">-&gt;</span> <span class="dt">Price</span></a>
<a class="sourceLine" id="cb13-9" title="9">aggregatePrices <span class="ot">=</span> _ <span class="co">-- some fold</span></a>
<a class="sourceLine" id="cb13-10" title="10"></a>
<a class="sourceLine" id="cb13-11" title="11"><span class="ot">fetchAndSave ::</span> (<span class="dt">Member</span> <span class="dt">PriceFeed</span> effs, <span class="dt">Member</span> <span class="dt">PriceStore</span> effs) <span class="ot">=&gt;</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> effs ()</a>
<a class="sourceLine" id="cb13-12" title="12">fetchAndSave assetPairing <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-13" title="13">    prices <span class="ot">&lt;-</span> getPricesFromAllSources assetPairing</a>
<a class="sourceLine" id="cb13-14" title="14">    <span class="kw">let</span> agg <span class="ot">=</span> aggregatePrices prices</a>
<a class="sourceLine" id="cb13-15" title="15">    savePrice assetPairing agg</a></code></pre></div>
<p>And for our request handler we have this embarrassingly small piece of code here. And since we actually want to wire this up to a real Yesod handler, let’s go ahead and do just that.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">getPriceH ::</span> <span class="dt">AssetPairing</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Value</span></a>
<a class="sourceLine" id="cb14-2" title="2">getPriceH assetPairing <span class="ot">=</span> <span class="op">???</span> <span class="op">$</span> <span class="fu">fmap</span> toJSON <span class="op">$</span> getMostRecentPrice assetPairing</a></code></pre></div>
<p>The astute reader might notice that we’re in the wrong monad here. We need to go from our <code>Eff</code> defined logic to the actual handler here.</p>
<p>The above code definitely cheats. Freer monads don’t save us from having to write all the grimy engineering details, but it <em>does</em> save us from having to interleave those details, or even commit to them. But when we actually wire into the web application, it’s time to make a commitment. After all we can’t avoid specifying how these prices will get fetched and saved in a real production environment.</p>
<h2 id="make-it-work">Make it work</h2>
<p>So what will our interpreters look like?</p>
<p>Well, since we’re fetching these prices from external parties, theres pretty much no avoiding going straight to IO, possibly with some sort of configuration for an api key.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">type</span> (<span class="op">~&gt;</span>) f g <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> g a <span class="co">-- from freer-simple</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="kw">data</span> <span class="dt">ExchangeConf</span> <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb15-3" title="3"><span class="ot">gdaxApiKey ::</span> <span class="dt">ExchangeConf</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="kw">data</span> <span class="dt">GDAXResponse</span> <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb15-5" title="5"><span class="ot">gdaxRespToPrice ::</span> <span class="dt">GDAXResponse</span> <span class="ot">-&gt;</span> <span class="dt">Price</span></a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="ot">asks ::</span> <span class="dt">Member</span> (<span class="dt">Reader</span>) r effs <span class="ot">=&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> effs a</a>
<a class="sourceLine" id="cb15-8" title="8">asks <span class="ot">=</span> _ <span class="co">-- from freer-simple</span></a>
<a class="sourceLine" id="cb15-9" title="9"></a>
<a class="sourceLine" id="cb15-10" title="10"><span class="ot">priceFeedToRIO ::</span> (<span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">ExchangeConf</span>) effs, <span class="dt">LastMember</span> <span class="dt">IO</span> effs) <span class="ot">=&gt;</span> <span class="dt">PriceFeed</span> <span class="op">~&gt;</span> <span class="dt">Eff</span> effs</a>
<a class="sourceLine" id="cb15-11" title="11">priceFeedToRIO action <span class="ot">=</span> <span class="kw">case</span> action <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-12" title="12">    <span class="dt">FetchPrice</span> exchange pairing <span class="ot">-&gt;</span> <span class="kw">case</span> exchange <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-13" title="13">        <span class="dt">GDAX</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-14" title="14">            <span class="co">-- GDAX actually doesn't require an api key for their price api, but I'm -- making this up because enough</span></a>
<a class="sourceLine" id="cb15-15" title="15">            <span class="co">-- third party services require some sort of auth that this felt like it'd be more helpful</span></a>
<a class="sourceLine" id="cb15-16" title="16">            key <span class="ot">&lt;-</span> asks gdaxApiKey</a>
<a class="sourceLine" id="cb15-17" title="17">            initReq <span class="ot">&lt;-</span> sendM <span class="op">.</span> parseRequest <span class="op">$</span> <span class="st">&quot;GET http://api.pro.coinbase.com/products/&quot;</span></a>
<a class="sourceLine" id="cb15-18" title="18">                <span class="op">&lt;&gt;</span> <span class="fu">show</span> pairing</a>
<a class="sourceLine" id="cb15-19" title="19">                <span class="op">&lt;&gt;</span> <span class="st">&quot;/ticker?apiKey=&quot;</span></a>
<a class="sourceLine" id="cb15-20" title="20">                <span class="op">&lt;&gt;</span> key</a>
<a class="sourceLine" id="cb15-21" title="21">            gdaxRespToPrice <span class="op">&lt;$&gt;</span> sendM (httpJson initReq)</a></code></pre></div>
<h2 id="test-it">Test it</h2>
<p>Great. We now have a way to legitimately fetch prices from a real place. But do we want to hit GDAX from our CI pipeline?</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">type</span> <span class="dt">ExchangeTestbed</span> <span class="ot">=</span> <span class="dt">HashMap</span> (<span class="dt">Exchange</span>, <span class="dt">AssetPairing</span>) <span class="dt">Price</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="ot">priceFeedToReader ::</span> (<span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">ExchangeTestbed</span>) effs) <span class="ot">=&gt;</span> <span class="dt">PriceFeed</span> <span class="op">~&gt;</span> <span class="dt">Eff</span> effs</a>
<a class="sourceLine" id="cb16-4" title="4">priceFeedToReader action <span class="ot">=</span> <span class="kw">case</span> action <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="dt">FetchPrice</span> exchange pairing <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-6" title="6">        hm <span class="ot">&lt;-</span> ask</a>
<a class="sourceLine" id="cb16-7" title="7">        <span class="co">-- It's a test interpreter for a conference talk, I'm cheating totality here</span></a>
<a class="sourceLine" id="cb16-8" title="8">        <span class="kw">let</span> price <span class="ot">=</span> fromJust <span class="op">$</span> <span class="fu">lookup</span> (exchange, pairing) </a>
<a class="sourceLine" id="cb16-9" title="9">        <span class="fu">pure</span> price</a></code></pre></div>
<p>So now we can test that our business logic saves the right data because we can control what data it gets to begin with.</p>
<h2 id="interpreters-are-reusable">Interpreters are reusable</h2>
<p>What does the PriceStore interpreter look like? Well it depends on how we want to store the data. Here we have some choices: an sql database (postgres), redis, live memory, or some combination of those.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">priceStoreToPostgres ::</span> ( <span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">ConnectionPool</span>) effs</a>
<a class="sourceLine" id="cb17-2" title="2">                        , <span class="dt">LastMember</span> <span class="dt">IO</span> effs</a>
<a class="sourceLine" id="cb17-3" title="3">                        ) <span class="ot">=&gt;</span> <span class="dt">PriceStore</span> <span class="op">~&gt;</span> <span class="dt">Eff</span> effs</a>
<a class="sourceLine" id="cb17-4" title="4">priceStoreToPostgres action <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-5" title="5">    pool <span class="ot">&lt;-</span> ask</a>
<a class="sourceLine" id="cb17-6" title="6">    Persistent.runSqlPool <span class="op">$</span> <span class="kw">case</span> action <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-7" title="7">        <span class="dt">SavePrice</span> pairing price <span class="ot">-&gt;</span> insert _ <span class="co">-- left as exercise</span></a>
<a class="sourceLine" id="cb17-8" title="8">        <span class="dt">GetMostRecentPrice</span> pairing <span class="ot">-&gt;</span> selectFirst _ <span class="co">-- left as exercise</span></a>
<a class="sourceLine" id="cb17-9" title="9"></a>
<a class="sourceLine" id="cb17-10" title="10"><span class="kw">type</span> <span class="dt">PriceCache</span> <span class="ot">=</span> <span class="dt">TVar</span> (<span class="dt">HashMap</span> <span class="dt">AssetPairing</span> <span class="dt">Price</span>)</a>
<a class="sourceLine" id="cb17-11" title="11"><span class="ot">priceStoreToPriceCache ::</span> ( <span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">PriceCache</span>) effs</a>
<a class="sourceLine" id="cb17-12" title="12">                          , <span class="dt">LastMember</span> <span class="dt">IO</span> effs</a>
<a class="sourceLine" id="cb17-13" title="13">                          ) <span class="ot">=&gt;</span> <span class="dt">PriceStore</span> <span class="op">~&gt;</span> <span class="dt">Eff</span> effs</a>
<a class="sourceLine" id="cb17-14" title="14">priceStoreToPriceCache action <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-15" title="15">    cache <span class="ot">&lt;-</span> ask</a>
<a class="sourceLine" id="cb17-16" title="16">    <span class="kw">case</span> action <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-17" title="17">    <span class="dt">SavePrice</span> pairing price <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-18" title="18">        sendM <span class="op">$</span> atomically <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-19" title="19">            cacheState <span class="ot">&lt;-</span> readTVar cache</a>
<a class="sourceLine" id="cb17-20" title="20">            <span class="kw">let</span> newCacheState <span class="ot">=</span> insert pairing price cacheState</a>
<a class="sourceLine" id="cb17-21" title="21">            writeTVar cache newCacheState</a>
<a class="sourceLine" id="cb17-22" title="22">    <span class="dt">GetMostRecentPrice</span> pairing <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-23" title="23">        sendM <span class="op">$</span> readTVarIO cache</a>
<a class="sourceLine" id="cb17-24" title="24"></a>
<a class="sourceLine" id="cb17-25" title="25"><span class="ot">priceStoreToPGandCache ::</span> ( <span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">ConnectionPool</span>) effs</a>
<a class="sourceLine" id="cb17-26" title="26">                          , <span class="dt">Member</span> (<span class="dt">Reader</span> <span class="dt">PriceCache</span>) effs</a>
<a class="sourceLine" id="cb17-27" title="27">                          , <span class="dt">LastMember</span> <span class="dt">IO</span> effs</a>
<a class="sourceLine" id="cb17-28" title="28">                          ) <span class="ot">=&gt;</span> <span class="dt">PriceStore</span> <span class="op">~&gt;</span> <span class="dt">Eff</span> effs</a>
<a class="sourceLine" id="cb17-29" title="29">priceStoreToPGandCache action <span class="ot">=</span> <span class="kw">case</span> action <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-30" title="30">    <span class="dt">SavePrice</span> _ _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-31" title="31">        priceStoreToPostgres action</a>
<a class="sourceLine" id="cb17-32" title="32">        priceStoreToPriceCache action</a>
<a class="sourceLine" id="cb17-33" title="33">    <span class="dt">GetMostRecentPrice</span> _ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-34" title="34">        <span class="co">-- no pg here because we're just reading, gotta go fast</span></a>
<a class="sourceLine" id="cb17-35" title="35">        priceStoreToPriceCache action </a></code></pre></div>
<p>Wow. So we just wrote two separate effects handlers and wrote a third one in terms of the other two. Hopefully this conveys that something you might encounter in a real world codebase can be turned into this style. This is still perhaps a simpler problem than the typical industry grade version, but it’s still more than a toy and should demonstrate the type of value you would get from doing something like this.</p>
<h1 id="why-shouldnt-i-use-this">Why shouldn’t I use this</h1>
<p>Alright alright, is it too good to be true? Just barely. The reasons why you may choose not to use this style in a production Haskell codebase are as follows:</p>
<ul>
<li>Monadic sections of your code can be slower</li>
<li>Resource bracketing can’t be expressed this way</li>
</ul>
<p>But hope is not lost, there is an alternative library that <a href="https://reasonablypolymorphic.com/">Sandy Maguire</a> just published called <a href="https://hackage.haskell.org/package/polysemy">polysemy</a> that pretty much fixes both of these problems. The only reason I didn’t write this post with that as the library being studied is because I haven’t had a chance to play with it in a production codebase yet.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Freer monads have made my code way more testable, better documented, and much better decomposed than it used to be without. I am by no means saying this is the only way for you to accomplish these things but it has certainly improved my code quality by quite a margin, and yet it remains practical enough for us to deploy real-world services that use this technique to production. If you have had a tough time testing IO code or find that you get this sense of fear when you see a type signature of <code>a -&gt; IO b</code>, maybe give this a shot and see if it solves your problems.</p>
<p>It is also worth noting that this technique can be introduced at the edges of your existing services without it infecting everything else, however the ergonomics of it skyrocket when you refactor your whole codebase to use this technique. Happy coding.</p>
<p>Until next time.</p>
<p>Peace.</p>
    </section>
</article>

        </main>

        <footer>
            <span style="float:left;">Bitcoin: <a href="https://www.blockchain.com/btc/address/32E3LJW2Mdc91t4e1V91pRwcMQKTALvwMG">32E3LJW2Mdc91t4e1V91pRwcMQKTALvwMG</a></span>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
